//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Xarm
{
    [Serializable]
    public class RobotMsgMsg : Message
    {
        public const string k_RosMessageName = "xarm_msgs/RobotMsg";
        public override string RosMessageName => k_RosMessageName;

        //  feedback information of the controlled robot
        //  state of robot: 
        // 	1 – RUNNING, executing motion command.
        // 	2 – SLEEPING, not in execution, but ready to move.
        // 	3 – PAUSED, paused in the middle of unfinished motion.
        // 	4 – STOPPED, not ready for any motion commands.
        // 	5 – CONFIG_CHANGED, system configuration or mode changed, not ready for motion commands.
        public short state;
        //  mode of robot:
        // 	0 for POSITION mode.(position control by xarm controller box, execute api standard commands)
        // 	1 for SERVOJ mode. (Immediate execution towards received joint space target, like a step response)
        // 	2 for TEACHING_JOINT mode. (Gravity compensated mode, easy for teaching)
        public short mode;
        //  cmdnum: number of commands waiting in the buffer.
        public short cmdnum;
        //  mt_brake: if translated to binary digits, each bit represent one axis, 1 for brake enabled, 0 for brake disabled
        public short mt_brake;
        //  mt_able: if translated to binary digits, each bit represent one axis, 1 for servo control enabled, 0 for servo disabled
        public short mt_able;
        //  error code (if non-zero)
        public short err;
        //  warning code (if non-zero)
        public short warn;
        //  current joint angles expressed in radian.
        public float[] angle;
        //  current TCP Cartesian position expressed in mm(position), radian(orientation)  
        public float[] pose;
        //  TCP offset from center of flange, with respect to tool frame.
        public float[] offset;

        public RobotMsgMsg()
        {
            this.state = 0;
            this.mode = 0;
            this.cmdnum = 0;
            this.mt_brake = 0;
            this.mt_able = 0;
            this.err = 0;
            this.warn = 0;
            this.angle = new float[0];
            this.pose = new float[6];
            this.offset = new float[6];
        }

        public RobotMsgMsg(short state, short mode, short cmdnum, short mt_brake, short mt_able, short err, short warn, float[] angle, float[] pose, float[] offset)
        {
            this.state = state;
            this.mode = mode;
            this.cmdnum = cmdnum;
            this.mt_brake = mt_brake;
            this.mt_able = mt_able;
            this.err = err;
            this.warn = warn;
            this.angle = angle;
            this.pose = pose;
            this.offset = offset;
        }

        public static RobotMsgMsg Deserialize(MessageDeserializer deserializer) => new RobotMsgMsg(deserializer);

        private RobotMsgMsg(MessageDeserializer deserializer)
        {
            deserializer.Read(out this.state);
            deserializer.Read(out this.mode);
            deserializer.Read(out this.cmdnum);
            deserializer.Read(out this.mt_brake);
            deserializer.Read(out this.mt_able);
            deserializer.Read(out this.err);
            deserializer.Read(out this.warn);
            deserializer.Read(out this.angle, sizeof(float), deserializer.ReadLength());
            deserializer.Read(out this.pose, sizeof(float), 6);
            deserializer.Read(out this.offset, sizeof(float), 6);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.Write(this.state);
            serializer.Write(this.mode);
            serializer.Write(this.cmdnum);
            serializer.Write(this.mt_brake);
            serializer.Write(this.mt_able);
            serializer.Write(this.err);
            serializer.Write(this.warn);
            serializer.WriteLength(this.angle);
            serializer.Write(this.angle);
            serializer.Write(this.pose);
            serializer.Write(this.offset);
        }

        public override string ToString()
        {
            return "RobotMsgMsg: " +
            "\nstate: " + state.ToString() +
            "\nmode: " + mode.ToString() +
            "\ncmdnum: " + cmdnum.ToString() +
            "\nmt_brake: " + mt_brake.ToString() +
            "\nmt_able: " + mt_able.ToString() +
            "\nerr: " + err.ToString() +
            "\nwarn: " + warn.ToString() +
            "\nangle: " + System.String.Join(", ", angle.ToList()) +
            "\npose: " + System.String.Join(", ", pose.ToList()) +
            "\noffset: " + System.String.Join(", ", offset.ToList());
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
